# K.   简单题

### 题意理解：

INPUT：

第一行 数据规模 n,目标 k。

第二行 n个整数，表示一个序列。

OUTPUT:

如果存在一个`1~k`的子序列，输出字典序最小的，否则输出 `Kanade`

### 思路和解法：

自己一开始用链表做，WA了，可能同样是贪，我就没有贪对，所以下面是看了题解的思路。

考虑我们要一个类似1 2 3 ... n，这样单调的数据结构，那么不是单调队列，就是单调栈，显然单调栈更像。

我们还是考虑贪心。如果此时新来一个元素，看见前面的元素大于它，并且后面依然拥有该元素，就弹出，直到任意一条件不满足，这显然能保证正确性（指不损失最终子序列元素个数），也一定程度上具有保持最优性的特点。

然而怎么证明最优呢？其实还有一条规则，如果当前元素已经在子序列出现，忽略该元素。因为按照我们的操作，如果说，前面的元素在后面有相同的元素，就有机会被弹出，如果没有被弹出是因为正确性的限制。那么可以看到，我们的贪心其实是在被正确性限制下的最优解。

细节见代码，有详细注释

### 时间复杂度：

可以看到，序列中任意一个数，最多进栈和出栈各一次，故线性。

$O(N)$

### 空间复杂度：

obviously

$O( N )$