# G.  红魔族首屈一指の鞋店老板之子

### 题意理解：

INPUT：

第一组 节点个数N和活动区间L。
第二组 N-1条边 以 `father weight` 的形式给出

OUTPUT:

每个节点在L范围内可以到达的子节点数+1

### 思路和解法：

思路和解法都是题解里的（大正解x

受到题解的影响，要用可并堆和从叶子节点做起

那可并堆怎么办呢？用左偏树实现？好像左偏树核心也就一个merge。等等，好像ACM可以用`pb_ds`，解决。

什么叫从叶子节点做起呢？那就是从叶子节点往上，每个节点维护一个堆，堆中存放子节点的距离，然后向上合并，并且记录堆的大小，大小就是活动范围即答案。

然后还有一些细节：

什么是子节点的距离？我们要删去堆中超过活动区间的点，如果我们堆中全部存储相对距离，那么会对堆进行频繁的修改，解决办法就是堆中存储到根节点的绝对距离，由于祖孙节点必然在一条简单路径上，直接相减可以得到相对距离。

一个中间节点可能有很多个子节点，什么时候向上合并呢？难道每个子节点向上合并，自己都向上合并吗？好像傻了点。解决办法是维护一个`cnt`，作为子节点数目，每次一个子节点向上合并之后视作该子节点被删除，到当前节点成为新的叶节点时向上合并。

更多细节见代码，有详细注释

### 时间复杂度：

我们知道，可并堆合并是$O(\log(N))$的，事实上，按照我们的合并被删除式理解，有N-1次合并，那么时间复杂度为

$O(Nlog(N))$

### 空间复杂度：

在此让我把`pb_ds`的内存管理想得美好一点。

除了堆以外，空间是$O(N)$的。

但是我们知道，每一个节点都有一个堆，而且根节点的堆显然是可以卡到N的，那么就是$O(N^2)$了吗？

等等，我们只在最开始为每个节点的堆中加入了自己，而后期处理只有堆合并和出堆，那么说明总的元素不超过N。如果内存管理**理想**，那就$O(N)$吧。

$O( N )$