# O. 臭数

### 思路和解法：

的确是数位DP板子题，不过这题让我好好了解了下这个板子。

按照出题人的题解，是类似不要62的思路，求出非回文的数目，再作差。但是这里有高精度减法，搞得我头疼，所以换了写法，直接统计回文串的数目。

一个串是回文串那么只需要看当前字符的前一个字符，前前一个字符是否和当前字符相同。那么需要两个参数last2和last1

一个串是回文串可能是当前字符参与构成回文串，或者以前字符构成回文串，所以需要一个found参数

当然在数位上需要一个cnt，一个limit，还有一个lead参数

**状态表示**：$dp[cnt][last2][last1][found]$，表示当前一个字符是last1，前前字符是last2，在cnt位到最低位，在没有limit限制下的回文串数目

**状态转移**：
$$
dp[cnt][last2][last1][found][lead][limit]=\Sigma (dp[cnt-1][last1][i][found||i=last1||i=last2][lead \and i=0][limit \and i=up])
$$
**初始状态**：

$dp[0][][][][][found]=found$

**递推顺序**：

对不起，记忆化搜索就是为所欲为。



一个坑：最后取模一定要(x%MOD+MOD)%MOD，因为solve(r)在模MOD意义下不一定大于solve(l)  5555555555



值得注意的是，数位DP在两次DP时并没有清除状态，这是由于两个原因，一个是数位DP是倒序的，这样尾部是对齐的，这样的话，子问题是重叠的，还有一个原因是！limit，因为limit于具体的上界有关，我们在记忆化的时候没有记忆与上界有关的部分，就实现了记忆的可复用性。



同样，可以注意到，这份代码没有使用！lead，这是由于手动让前导零变为10，所以不会出现前导零冲突。



细节看代码，代码有详细注释

### 时间复杂度：

$O(log(R))$ ???不会不会，貌似数位DP基本上不卡时间复杂度，用了数位就行？

### 空间复杂度：

$O( L )$   L为数位数目

或者$O(\log(R))$