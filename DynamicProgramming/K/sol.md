# K. 狂风呼啸，此时站在你面前的是一队真正的特种兵Ⅱ

### 思路和解法：

这题和 J 题很类似     ~~所以题解也很类似~~   ~~也很和出题人的题解类似~~

***首先，有一个结论，就是通过两两交换使得原序列变得有序的最小步数，就是逆序对的步数。当然，这句话要广义上去理解，所谓序不一定是数的大小，只要是一种排列方式即可，逆序对也相应推广为违反了该排列方式的数对数目。***

由于相同组的特种兵一定排列在一起，那么我们就不对单个特种兵枚举，而是枚举兵种的排列。



那么，这是一道DP题，如何转化为子问题呢？

思考的结果可以是，按照构造排列的方式来――构造一个排列，只需要在子排列（子问题）后面选取并添加上一个新元素。

那么，有**状态转移方程**
$$
dp[S]=min(dp[S \setminus \{i\}]+\Sigma(w[i][j]))   \quad 对于任意i \in S, j \in S，并且i!=j
$$
其中 $w[i][j]$ 代表原序列中 $i$ 在 $j$ 前面的对数，显然由于我们是最后选取 $i$ ，那么 $j$ 就一定在 $i$ 前，所以这就代表逆序对。可见这里是人为地为集合建立了序（排列）。

显然$w[i][j]$需要预处理，代码如下

![image-20200522182007278](C:\Users\tungsten\Documents\AcmTrain\DynamicProgramming\K\w.png)



那么如何**表示集合**呢？这里就是状态压缩了。

使用集合的二进制表示法，存在为1，不存在为0，那么每一位就可以表示一个元素的存在情况，考虑到兵种只有20种，可以使用一个32位integer解决空间问题。



那么**初始状态**是什么呢？显然$dp[\empty]=0$



那么如何确定**递推顺序**？如何保证子问题被预先处理呢？考虑到子问题相对于原问题一定是把某一位的1置为了0，那么子问题的状态肯定在数值表示下小于原问题，那么我们只需要按照数值从小到大枚举。



具体看代码，有注释

### 时间复杂度：

时间复杂度包括两部分，**预处理w数组**部分和**DP**部分

**预处理w数组**

$O(NM)$



**DP**

枚举所有子问题是$O(M)$

统计逆序对是 $O(M)$

所有集合数目是$O(2^M)$

那么DP的复杂度上界为$O(M^2 2^M)$



故总复杂度$O(NM+M^2 2^M)$



### 空间复杂度：

状态数组$O(2^M)$
