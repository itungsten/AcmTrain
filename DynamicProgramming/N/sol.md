# N. 猛男修树



### 思路和解法：

树上DP，泛化物品的背包？

**状态表示**：$dp[i][j]$ 表示 i 节点的子树 修剪为 j 个节点所需最小修剪次数

**状态转移**:  
$$
\forall z 是i的子节点，k<=z的子树大小 \quad dp[i][j]=min(dp[i][j-k]+dp[i][k]-1,dp[i][j])
$$
**初始状态**：

记每个节点儿子的数目为son[i]，那么
$$
\forall i \quad dp[i][1]=son[i]
$$
其余无穷大。

**枚举顺序**：

代码内实现状态转移的时候，类似背包。对于每颗子树，可以看作一个泛化物品，都要按照体积DP，同样顺序也和01背包一样，一定要倒序更新。



一个坑：最后求答案时不能只管根节点，还要比较其他节点，而且非根节点还要加一以断开与父节点的边

细节看代码，代码有注释

### 时间复杂度：

每个节点$O(N)$

节点的每个子节点$O(N)$

子节点子树每种被修剪大小$O(N)$

相乘$O(N^3)$

### 空间复杂度：

$O(NP)$